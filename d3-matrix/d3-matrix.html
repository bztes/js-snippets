<!--
Copyright 2019 Nico Beierle <nico.beierle@gmail.com>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <style>
    body {
      font: 10px sans-serif;
    }

    #chart {
      position: fixed;
      left: 0px;
      right: 0px;
      top: 0px;
      bottom: 0px;
    }

    svg rect.link {
      width: 12px;
      height: 12px;
      rx: 6px;
      ry: 6px;
      transform: translate(-6px, -6px);
    }

    svg rect.link:hover {
      transform: translate(-10px, -10px);
      width: 20px;
      height: 20px;
      rx: 0px;
      ry: 0px;
      transition: .25s ease;
    }

    svg rect.selection {
      fill: #eee;
    }

    svg text.fold {
      font-weight: bold;
      cursor: default;
    }

    div.tooltip {
      position: absolute;
      background: #111;
      color: #fff;
      pointer-events: none;
      padding: 5px;
      margin: 10px 0 0 10px;
      border-radius: 3px;
    }
  </style>
</head>

<body>
  <div ondragover="dragoverHandler(event)" ondrop="loadFile(event)" id="chart"></div>
  <script>
    var data = {};

    var chartDiv = document.getElementById("chart");
    var svg = d3.select(chartDiv).append("svg");
    var tooltip = d3.select("body").append("div").attr("class", "tooltip").style("opacity", 0);

    svg.attr("width", "100%")
      .attr("height", "100%");

    var matrix = {};

    var nodeSize = 20;
    var headerSize = 300;
    var transTime = 250;
    var childIndent = 10;

    var g = svg.append("g");
    var highlightGroup = g.append("g").attr("class", "highlightGroup");
    var linksAxis = g.append("g").attr("class", "linksAxis").attr("transform", `translate(${headerSize}, ${headerSize})`);
    var columnsAxis = g.append("g").attr("class", "columnsAxis").attr("transform", `translate(${headerSize}, ${headerSize - nodeSize}) rotate(-90)`);
    var rowsAxis = g.append("g").attr("class", "rowsAxis").attr("transform", `translate(0, ${headerSize})`);

    svg.call(d3.zoom()
      .scaleExtent([0.1, 8])
      .on("zoom", zoomed))
      .on("dblclick.zoom", null);

    function dragoverHandler(evt) {
      evt.stopPropagation();
      evt.preventDefault();
      evt.dataTransfer.dropEffect = 'copy';
    }

    function loadFile(event) {
      event.stopPropagation();
      event.preventDefault();

      var reader = new FileReader();
      reader.onload = (loadEvent) => this.loadCSV(loadEvent.target.result);
      reader.readAsText(event.dataTransfer.files[0]);
    }

    function loadCSV(csvString) {
      var jsonData = toJson(d3.csvParse(csvString));

      data.root = packageHierarchy(jsonData);

      updateStructData(data.root);

      data.matrix = createMatrix(data.root);

      data.tNodeStates = [...new Array(data.root.descCount)].map(() => ({
        collapsed: false,
        index: -1
      }));
      data.sNodeStates = [...new Array(data.root.descCount)].map(() => ({
        collapsed: false,
        index: -1
      }));

      redraw();
    }

    function toJson(data) {
      var map = {};

      data.forEach(r => {
        var source = map[r.source];
        if (!source) {
          source = map[r.source] = {
            name: r.source,
            out: []
          };
        }

        var target = map[r.target];
        if (!target) {
          target = map[r.target] = {
            name: r.target,
            out: []
          };
        }

        source.out.push(target);
      });

      return Object.values(map);
    }

    function packageHierarchy(leafs) {
      var map = {};

      function find(name, data) {
        var node = map[name];
        if (!node) {
          node = map[name] = data || {
            name: name,
            out: []
          };
          node.children = [];
          if (name.length) {
            var i = name.lastIndexOf(".");
            node.parent = find(name.substring(0, i).toLowerCase());
            node.parent.children.push(node);
          }
        }
        return node;
      }

      leafs.forEach(d => find(d.name, d));

      return map[""];
    }

    function updateStructData(node, index = 0, depth = 0) {
      node.index = index;
      node.depth = depth;
      node.descCount = 1;
      if (node.children) {
        node.children.forEach(n => {
          index = updateStructData(n, ++index, depth + 1);
          node.descCount += n.descCount;
        });
      }
      return index;
    }

    function zoomed() {
      g.attr("transform", d3.event.transform);
    }

    function toggleCollapse(nodeIndex, nodeStates) {
      var nodeState = nodeStates[nodeIndex];
      nodeState.collapsed = !nodeState.collapsed;
      redraw();
    }

    function treeList(node, nodeStates, list = []) {
      var nodeState = nodeStates[node.index];
      nodeState.index = list.length;
      list.push(node);
      if (node.children && !nodeState.collapsed) {
        node.children.forEach(n => treeList(n, nodeStates, list));
      }
      return list;
    }

    function linkList(sNodes, tNodes) {
      var links = [];
      for (var s = 0; s < sNodes.length; s++) {
        var sNode = sNodes[s];
        for (var t = 0; t < tNodes.length; t++) {
          var tNode = tNodes[t];
          var value = data.matrix[sNode.index][tNode.index];
          if (value > 0) {
            links.push({
              source: sNode,
              target: tNode,
              sIndex: s,
              tIndex: t,
              value: value
            });
          }
        }
      };
      return links;
    }

    function createMatrix(root) {
      var matrix = Array(root.descCount).fill().map(() => Array(root.descCount).fill(0));

      function update(source) {
        source.out.forEach(t => {
          matrix[source.index][t.index] = 1;
        });

        source.children.forEach(c => {
          update(c);
        });

        agg(source, root);
      }

      function agg(source, target) {
        target.children.forEach(c => {
          agg(source, c);
          // agg columns
          matrix[source.index][target.index] += matrix[source.index][c.index];
          // agg rows but only leaf values, nodes have already been aggregated by columns
          if (source.parent && c.children.length == 0) {
            matrix[source.parent.index][c.index] += matrix[source.index][c.index];
          }
        });
      }

      update(root);

      return matrix;
    }

    function setTooltip(html) {
      if (html) {
        tooltip.html(html)
          .style("left", (d3.event.pageX) + "px")
          .style("top", (d3.event.pageY) + "px")
          .style("opacity", 1);
      } else {
        tooltip.style("opacity", 0);
      }
    }

    function redrawAxis(group, nodes, nodeStates) {
      var axis = group.selectAll("g").data(nodes, d => d.index);
      axis.exit().remove();
      var entered = axis.enter().append("g")
        .attr("transform", d => `translate(0, ${d.parent ? nodeStates[d.parent.index].index * nodeSize : 0})`)
        .style("opacity", 0)
        .on("mouseover", (d, i) => highlight(nodeStates[d.index].index, nodes.length, nodes === data.sNodes))
        .on("mouseout", clearHighlight)
      var merge = entered.merge(axis)
        .transition().duration(transTime)
        .attr("transform", (d, i) => `translate(0, ${i * nodeSize})`)
        .style("opacity", 1);

      entered.append("text")
        .attr("class", "fold")
        .attr("dy", ".35em")
        .attr("x", d => d.depth * childIndent)
        .on("mousedown", d => toggleCollapse(d.index, nodeStates));

      merge.select(".fold")
        .text(d => {
          if (d.children.length > 0) {
            return nodeStates[d.index].collapsed ? "[+]" : "[-]";
          }
          return null;
        });

      entered.append("text")
        .attr("dy", ".35em")
        .attr("x", d => d.depth * childIndent + 25)
        .text(d => d.name);
    }

    function redraw() {
      data.sNodes = treeList(data.root, data.sNodeStates);
      data.tNodes = treeList(data.root, data.tNodeStates);

      redrawAxis(rowsAxis, data.sNodes, data.sNodeStates);
      redrawAxis(columnsAxis, data.tNodes, data.tNodeStates);

      data.links = linkList(data.sNodes, data.tNodes);

      var linkCircle = linksAxis.selectAll(".link").data(data.links, d => d.sIndex + "-" + d.tIndex);
      linkCircle.exit().remove();
      linkCircle.enter().append("rect")
        .attr("class", "link")
        .style("opacity", 0)
        .on("mouseover", d => {
          highlight(d.sIndex, data.tNodes.length, true);
          highlight(d.tIndex, data.sNodes.length, false);
          setTooltip(`<b>Source:</b> ${d.source.name}<br><b>Target:</b> ${d.target.name}<br><b>Links:</b> ${d.value}`);
        })
        .on("mouseout", _ => {
          clearHighlight();
          setTooltip(null);
        })
        .merge(linkCircle)
        .attr("x", (d, i) => d.tIndex * nodeSize)
        .attr("y", (d, i) => d.sIndex * nodeSize)
        .transition().duration(transTime)
        .style("opacity", 1);
    }

    function highlight(i, length, row) {
      highlightGroup.append("rect")
        .attr("class", "selection")
        .attr(row ? "x" : "y", 0)
        .attr(row ? "y" : "x", headerSize + i * nodeSize - nodeSize / 2)
        .attr(row ? "width" : "height", headerSize + length * nodeSize)
        .attr(row ? "height" : "width", nodeSize);
    }

    function clearHighlight() {
      highlightGroup.selectAll("rect").remove();
    }
  </script>
</body>